<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>人権を得たいゴミ </title>
    <link>http://upamune.github.io/post/</link>
    <language>en-us</language>
    <author>Masato Yamamoto</author>
    <rights>(C) 2015</rights>
    <updated>2015-11-13 21:57:54 &#43;0900 &#43;0900</updated>

    
      
        <item>
          <title>ES6を学んだ</title>
          <link>http://upamune.github.io/blog/2015/11/13/studying-es6/</link>
          <pubDate>Fri, 13 Nov 2015 21:57:54 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/11/13/studying-es6/</guid>
          <description>&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/mROC1f3.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Electronで作りたいものが出てきたのだけれど, なにか新しい技術を使ってみたくて悩んでいる. &lt;code&gt;ES6 + React&lt;/code&gt; か &lt;code&gt;TypeScript + Angular&lt;/code&gt; って感じ. ES6でどんな変更があったんだっけって時は &lt;a href=&#34;http://es6-features.org/&#34;&gt;ECMAScript 6: New Features: Overview and Comparison&lt;/a&gt; がべんり.&lt;/p&gt;

&lt;p&gt;実際にさわってみたかったので, tower-of-babelを一通りやってみた. &lt;a href=&#34;https://github.com/yosuke-furukawa/tower-of-babel&#34;&gt;yosuke-furukawa/tower-of-babel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;やってみた感想としては, ES6すごいべんりって感じ. 個人的には イテレータ &amp;amp; ジェネレータとかアロー関数がすごいべんりそうだった.
ジェネレータ, さらに学びたい =&amp;gt; &lt;a href=&#34;https://github.com/isRuslan/learn-generators&#34;&gt;isRuslan/learn-generators&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;短時間で全部終わらせることができるので, 是非.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[x] ES6&lt;/li&gt;
&lt;li&gt;[ ] React&lt;/li&gt;
&lt;li&gt;[ ] TypeScript&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あとは, ReactとTypeScriptが残っているのではやくやりたい. けど, 今週末は予定があるのでしばらく先になりそう.
&lt;a href=&#34;https://github.com/kohei-takata/learnyoureact&#34;&gt;kohei-takata/learnyoureact&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このシリーズめっちゃいいな.  &lt;a href=&#34;http://nodeschool.io/#workshoppers&#34;&gt;NodeSchool&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>YAPC::Asia 2015に参加してきた!! #yapcasia</title>
          <link>http://upamune.github.io/blog/2015/08/22/yapc-asia-2015/</link>
          <pubDate>Sat, 22 Aug 2015 23:11:02 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/08/22/yapc-asia-2015/</guid>
          <description>

&lt;p&gt;8月21,22日の2日間、YAPC:Asiaに参加してきた。YAPCは今年が初参加で、20日の前夜祭は用事があって行けなくて残念だった。「ブログを書くまでがYAPC」と言われたので初YAPC感想を書く。&lt;/p&gt;

&lt;h1 id=&#34;1日目:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;1日目&lt;/h1&gt;

&lt;p&gt;会場には早めに到着した。てっきり10時開始だと思っていたら9時45分くらいから始まって、早めに来ておいてよかった感。
&lt;blockquote class=&#34;twitter-tweet&#34; data-cards=&#34;hidden&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;YAPC!!!!!!! (@ 東京国際展示場 (東京ビッグサイト/Tokyo Big Sight) - &lt;a href=&#34;https://twitter.com/T_Bigsight&#34;&gt;@t_bigsight&lt;/a&gt; in Koto, 東京都) &lt;a href=&#34;https://t.co/viwbKTMXsD&#34;&gt;https://t.co/viwbKTMXsD&lt;/a&gt;&lt;/p&gt;&amp;mdash; 採 用 目 的 (@upamune) &lt;a href=&#34;https://twitter.com/upamune/status/634519260124053506&#34;&gt;2015, 8月 21&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;とりあえず,1日目は以下のセッションを聴いた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/a636430c-0fbf-11e5-8a02-43ec7d574c3a&#34;&gt;メリークリスマス！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/44721562-10e4-11e5-88a0-d7f07d574c3a&#34;&gt;Effective ES6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/94051590-fb11-11e4-a39d-8ab37d574c3a&#34;&gt;今フロントエンドで何が起こっているのか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/de9e7a1e-136d-11e5-a9fc-d9f87d574c3a&#34;&gt;Perlの上にも三年 〜 ずっとイケてるサービスを作り続ける技術 〜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/c191c08a-0a98-11e5-be34-67dc7d574c3a&#34;&gt;esa.io - 趣味から育てたWebサービスで生きていく&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;それぞれ簡単に感想を書いていく。詳細に知りたかったら、スライドを見るのはもちろんのこと、togetterを見るのもいいと思う。&lt;/p&gt;

&lt;h2 id=&#34;メリークリスマス:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;メリークリスマス！&lt;/h2&gt;

&lt;p&gt;Perlのパパ、Larry Wallのお話。同時通訳があって本当に良かった。けど、トールキン全然知らなくて話の半分も理解できなかった。&lt;/p&gt;

&lt;h2 id=&#34;effective-es6:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;Effective ES6&lt;/h2&gt;

&lt;p&gt;ES6の話で、人気セッションだった。ES6を使うことで今までやってたベストプラクティス的なことをやらなくても良いことがよく分かった。バベります。&lt;/p&gt;

&lt;h2 id=&#34;今フロントエンドで何が起こっているのか:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;今フロントエンドで何が起こっているのか&lt;/h2&gt;

&lt;p&gt;Ajax以降のフロントエンドの変遷を現代までなぞってくる感じだった。&lt;a href=&#34;https://reduxframework.com/&#34;&gt;Redux&lt;/a&gt;というフレームをはじめて知ったので後で試してみる。スライドを見なおしていて、これが1時間で収まったのか&amp;hellip;と不思議な気分になった。&lt;/p&gt;

&lt;h2 id=&#34;perlの上にも三年-ずっとイケてるサービスを作り続ける技術:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;Perlの上にも三年 〜 ずっとイケてるサービスを作り続ける技術 〜&lt;/h2&gt;

&lt;p&gt;Perl書いたことないけどおもしろそうなのでひょこひょこ行ったら、めっちゃおもしろかった、最高。会場がめっちゃ盛り上がっていた。DDD最高。&lt;/p&gt;

&lt;h2 id=&#34;esa-io-趣味から育てたwebサービスで生きていく:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;esa.io - 趣味から育てたWebサービスで生きていく&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://esa.io&#34;&gt;esa.io&lt;/a&gt;の中の人の話を聞いた。今回で一番刺激を受けたセッションかもしれない。実際にいろいろやってみること大事だなと感じた。翌日に中の人からステッカーと缶バッチを頂いた。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;esa. ioのステッカーと缶バッジいただきました！！ &lt;a href=&#34;https://twitter.com/hashtag/esa_io?src=hash&#34;&gt;#esa_io&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/yapcasia?src=hash&#34;&gt;#yapcasia&lt;/a&gt; &lt;a href=&#34;http://t.co/6zh1bwF3Dg&#34;&gt;pic.twitter.com/6zh1bwF3Dg&lt;/a&gt;&lt;/p&gt;&amp;mdash; 採 用 目 的 (@upamune) &lt;a href=&#34;https://twitter.com/upamune/status/634928713415528449&#34;&gt;2015, 8月 22&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;2日目:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;2日目&lt;/h1&gt;

&lt;p&gt;2日目は以下のセッションを聴いた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/86ebd212-fab3-11e4-8f5a-8ab37d574c3a&#34;&gt;ISUCONの勝ち方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/93eaf068-faec-11e4-a8fd-8ab37d574c3a&#34;&gt;NASA主催の世界最大級ハッカソンSpaceAppsを運営した話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/5ea2630a-133d-11e5-8cbb-d9f87d574c3a&#34;&gt;Docker３兄弟について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/a4318242-f5f2-11e4-afb7-49b37d574c3a&#34;&gt;実践nginxモジュール開発〜CとLua〜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/ad57ca84-13e9-11e5-aca1-525412004261&#34;&gt;【特別企画】YAPCあるある（仮）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yapcasia.org/2015/talk/show/6bde6c69-187a-11e5-aca1-525412004261&#34;&gt;Profiling &amp;amp; Optimizing in Go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;isuconの勝ち方:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;ISUCONの勝ち方&lt;/h2&gt;

&lt;p&gt;ISUCON出たいと考えているので行った。一番メモしたセッションだと思う。後ほど、2014年の夏期講習のスライドも見てみよう。&lt;/p&gt;

&lt;h2 id=&#34;nasa主催の世界最大級ハッカソンspaceappsを運営した:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;NASA主催の世界最大級ハッカソンSpaceAppsを運営した&lt;/h2&gt;

&lt;p&gt;いつもイベントには参加する側で主催するなんて考えたことがなかったけど、主催してみるのも面白そう。引き継ぎ大事。&lt;/p&gt;

&lt;h2 id=&#34;docker３兄弟について:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;Docker３兄弟について&lt;/h2&gt;

&lt;p&gt;docker-compose, docker-swarm, docker-machine をDocker3兄弟と呼んでそれぞれの使い方を説明していた。docker-composeしか使ったことがないけど, docker-machine もべんりそうなので使ってみよう。 docker-swarm は使わなそうだな&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;実践nginxモジュール開発-cとlua:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;実践nginxモジュール開発〜CとLua〜&lt;/h2&gt;

&lt;p&gt;最初にCでのモジュール開発の方法を紹介してからLuaでの開発方法を紹介してた。Luaめっちゃ楽やんけってなった。実際ほとんどのケースではLuaで大丈夫らしい。&lt;a href=&#34;https://openresty.org/&#34;&gt;OpenResty&lt;/a&gt; というべんりそうなのも教えてもらった。&lt;/p&gt;

&lt;h2 id=&#34;特別企画-yapcあるある-仮:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;【特別企画】YAPCあるある（仮）&lt;/h2&gt;

&lt;p&gt;これまでのYAPCのお話。今年は来場者が2000人を超えたらしくてすごみ。最初で最後のYAPCになってしまったのが残念。去年も参加すればよかった。&lt;/p&gt;

&lt;h2 id=&#34;profiling-optimizing-in-go:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;Profiling &amp;amp; Optimizing in Go&lt;/h2&gt;

&lt;p&gt;Golangだから行ってみようと軽い気持ちで行ったけど、最高だった。ライブコーディング熱かった。Goのツールべんりなのがたくさんあるな&amp;hellip;。しかもこのセッション用のリポジトリを用意してくれてて後から試せるようになっている、最高。 &lt;a href=&#34;https://github.com/bradfitz/talk-yapc-asia-2015&#34;&gt;bradfitz/talk-yapc-asia-2015&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;雑なまとめ:fa24617dd4c18bb691a3deb81e6f2e6b&#34;&gt;雑なまとめ&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;めちゃめちゃWiFiが快適で感動&lt;/li&gt;
&lt;li&gt;懇親会は申し込み忘れてて行けなかった&lt;/li&gt;
&lt;li&gt;同時通訳めっちゃありがたい&lt;/li&gt;
&lt;li&gt;ライトニングトークめちゃ良かった&lt;/li&gt;
&lt;li&gt;なかなか人に会うのが難しかった（アイコンがないと誰なのかわからない問題&lt;/li&gt;
&lt;li&gt;裏でやってて聴けなかったセッションもスライドが上げられててめちゃ感謝&lt;/li&gt;
&lt;li&gt;YAPC::Asia 最高!!&lt;/li&gt;
&lt;li&gt;採用目的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;※小学生並みの感想で申し訳ない感&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Pythonをはじめたので環境設定のメモ</title>
          <link>http://upamune.github.io/blog/2015/08/08/start-python/</link>
          <pubDate>Sat, 08 Aug 2015 16:33:31 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/08/08/start-python/</guid>
          <description>

&lt;p&gt;新しい言語を始めるときは環境設定が一番面倒くさい。Pythonって2系と3系どっちやればええねんって感じがする。&lt;/p&gt;

&lt;p&gt;とりあえず、諸々のインストールから。&lt;/p&gt;

&lt;h1 id=&#34;python-インストール:64c1f73bb56d633e928eb20c34f97166&#34;&gt;Python インストール&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S python # Python2.x は python2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでPython3.x が入る。&lt;/p&gt;

&lt;p&gt;PythonにはRubyでいうところの &lt;code&gt;gem&lt;/code&gt; 的な &lt;code&gt;pip&lt;/code&gt; というものがあるらしいのでそれも一緒にインストールしておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S python-pip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あと &lt;code&gt;virtualenv&lt;/code&gt; っていうやつも入れるらしい。 &lt;code&gt;Bundler&lt;/code&gt; 的なものかな？ &lt;code&gt;virtualenv&lt;/code&gt; のラッパーの &lt;code&gt;virtualenvwrapper&lt;/code&gt; も一緒にさっき導入した &lt;code&gt;pip&lt;/code&gt; を使ってインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pip install virtualenv virtualenvwrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをインストールしたら &lt;code&gt;.zshrc&lt;/code&gt; に以下を書いて、パスを通してスクリプトを読み込むようにしておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;if which virtualenvwrapper.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 ; then
  export WORKON_HOME=$HOME/.virtualenvs
  source `which virtualenvwrapper.sh`
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;code&gt;virtualenv&lt;/code&gt; が使えるようになったらしい。&lt;/p&gt;

&lt;p&gt;環境を作るには &lt;code&gt;mkvirtualenv&lt;/code&gt; , 環境を切り替えるには &lt;code&gt;workon&lt;/code&gt; , デフォルトにするなら &lt;code&gt;deactivate&lt;/code&gt; を使えばいいらしい。
一覧は &lt;code&gt;lsvirtualenv&lt;/code&gt; , 削除は &lt;code&gt;rmvirtualenv&lt;/code&gt; 。 他のコマンドについては&lt;a href=&#34;https://virtualenvwrapper-docs-ja.readthedocs.org/en/latest/command_ref.html#id2&#34;&gt;ここ&lt;/a&gt;を参照すると良さそう。&lt;/p&gt;

&lt;h1 id=&#34;vim-の設定:64c1f73bb56d633e928eb20c34f97166&#34;&gt;Vim の設定&lt;/h1&gt;

&lt;p&gt;だいたいインストールしなければいけないものはインストールし終わったので、Vimで快適にPythonを書くための設定を行う。設定したいと思っているのは以下の項目。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;シンタックスチェック&lt;/li&gt;
&lt;li&gt;コード補完&lt;/li&gt;
&lt;li&gt;コーディング規約チェック&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;シンタックスチェック:64c1f73bb56d633e928eb20c34f97166&#34;&gt;シンタックスチェック&lt;/h2&gt;

&lt;p&gt;シンタックスチェックには &lt;code&gt;flake8&lt;/code&gt; を利用する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pip install flake8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で, &lt;code&gt;flake8&lt;/code&gt; をインストールできたので、あとは設定を書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vimscript&#34;&gt;let g:syntastic_python_checkers = [&amp;quot;flake8&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コード補完:64c1f73bb56d633e928eb20c34f97166&#34;&gt;コード補完&lt;/h2&gt;

&lt;p&gt;補完には &lt;code&gt;jedi-vim&lt;/code&gt; を利用する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vimscript&#34;&gt;NeoBundle &amp;quot;davidhalter/jedi-vim&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デフォルトの設定では使いづらいところがあるので設定を書いておく。
ここを参照した。 &lt;a href=&#34;http://dackdive.hateblo.jp/entry/2014/08/13/130000&#34;&gt;[vim]python補完プラグイン「jedi-vim」を快適にする方法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vimscript&#34;&gt;autocmd FileType python setlocal completeopt-=preview
autocmd FileType python setlocal omnifunc=jedi#completions
let g:jedi#auto_vim_configuration = 0
if !exists(&#39;g:neocomplete#force_omni_input_patterns&#39;)
  let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#force_omni_input_patterns.python = &#39;\h\w*\|[^. \t]\.\w*&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは &lt;code&gt;jedi&lt;/code&gt; プラグインの中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git submodule update --init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行すると使用できるようになる。&lt;/p&gt;

&lt;h2 id=&#34;コーディング規約チェック:64c1f73bb56d633e928eb20c34f97166&#34;&gt;コーディング規約チェック&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;pep8&lt;/code&gt; 準拠のコードを書くように指摘してもらうようにする。
保存時にチェックしてもらうために, &lt;code&gt;andviro/flake8-vim&lt;/code&gt; を入れる。
設定も書いておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vimscript&#34;&gt;NeoBundle &amp;quot;andviro/flake8-vim&amp;quot;
let g:PyFlakeOnWrite = 1
let g:PyFlakeCheckers = &#39;pep8&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは &lt;code&gt;pep8&lt;/code&gt; 基準のインデントするようにしたいので, &lt;code&gt;hynek/vim-python-pep8-indent&lt;/code&gt; もインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vimscript&#34;&gt;NeoBundle &amp;quot;hynek/vim-python-pep8-indent&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;その他:64c1f73bb56d633e928eb20c34f97166&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vim-virtualenv&lt;/code&gt; っていう &lt;code&gt;virtualenv&lt;/code&gt; をべんりに扱えるプラギンがあるらしいのでそれも入れておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vimscript&#34;&gt;NeoBundle &amp;quot;jmcantrell/vim-virtualenv&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ:64c1f73bb56d633e928eb20c34f97166&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;やっぱり新しい言語を始めるときは環境設定が面倒くさいなぁ。PythonはRubyより厳格で,書き方が限られていて好き。これでようやく&lt;a href=&#34;http://www.cl.ecei.tohoku.ac.jp/nlp100/&#34;&gt;言語処理100本ノック&lt;/a&gt; を始められる。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Macクリーンインストールした時のメモ</title>
          <link>http://upamune.github.io/blog/2015/07/22/mac_clean_install/</link>
          <pubDate>Wed, 22 Jul 2015 22:11:38 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/22/mac_clean_install/</guid>
          <description>

&lt;p&gt;3ヶ月に1回くらいMacをクリーンインストールして再設定するのでその時のためにメモ。&lt;/p&gt;

&lt;p&gt;インストールしたらAppStoreを開いてアップデートがないかどうか確認してから以下に進む。あればアップデートする。&lt;/p&gt;

&lt;h1 id=&#34;homebrew-インストール:092daf0005039ce086d26e3201a21bf4&#34;&gt;Homebrew インストール&lt;/h1&gt;

&lt;p&gt;まずHomebrewのインストールをする。その時に一緒にコマンドラインツールもインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでHomebrewを導入できたら必要なツールをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew install clang-format ctags docker gcc git go heroku-toolbelt ruby the_silver_searcher tig tmux tree zsh
$ brew install vim --with-lua --override-system-vi --HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go関連のツールを導入する。pecoもHomebrewではなくてgo get で導入する。
以下のツールをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go get -u golang.org/x/tools/cmd/goimports
$ go get -u golang.org/x/tools/cmd/godoc
$ go get -u golang.org/x/tools/cmd/vet
$ go get -u golang.org/x/tools/cmd/cover
$ go get -u github.com/nsf/gocode
$ go get -u github.com/golang/lint/golint
$ go get -u code.google.com/p/rog-go/exp/cmd/godef
$ go get -u github.com/jstemmer/gotags
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;シェル周りの設定:092daf0005039ce086d26e3201a21bf4&#34;&gt;シェル周りの設定&lt;/h1&gt;

&lt;h2 id=&#34;ログインシェルの変更:092daf0005039ce086d26e3201a21bf4&#34;&gt;ログインシェルの変更&lt;/h2&gt;

&lt;p&gt;これでHomebrewでインストールしたzshをログインシェルとして選択できるようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo `which zsh` | sudo tee -a /etc/shells
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてログインシェルをzshに変更する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chsh -s `which zsh`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim-と-zsh-の設定:092daf0005039ce086d26e3201a21bf4&#34;&gt;Vim と Zsh の設定&lt;/h2&gt;

&lt;p&gt;自分の場合はdotfiles にまとめてあるのでそのリポジトリをクローンしてくる。ので、GithubにSSH鍵を登録しておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;んで&lt;code&gt;~/.ssh/config&lt;/code&gt;に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host github.com
      User git
      Port 22
      Hostname github.com
      IdentityFile ~/.ssh/github
      TCPKeepAlive yes
      IdentitiesOnly yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;書いて&lt;code&gt;~/.ssh/github.pub&lt;/code&gt; をGithub側に登録すればよい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone git@github.com:upamune/dotfiles.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、dotfilesディレクトリに入って、&lt;code&gt;init.sh&lt;/code&gt;を実行する。実行し終わったら、&lt;code&gt;exec zsh&lt;/code&gt; をする。そしてtmux上で &lt;code&gt;C-t I&lt;/code&gt; を押してtmuxのプラグインをインストール。Vimを起動してプラグインをインストールする。&lt;/p&gt;

&lt;p&gt;そしてここで1度(気分的に)再起動する。&lt;/p&gt;

&lt;h1 id=&#34;guiアプリケーション:092daf0005039ce086d26e3201a21bf4&#34;&gt;GUIアプリケーション&lt;/h1&gt;

&lt;p&gt;必要なGUIアプリケーションをインストールしていく。ここが一番面倒くさいところ。すべて手動でインストールする。brew-caskは嫌いなので使わない。太字になっているものはAppStoreからダウンロードする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1Password&lt;/li&gt;
&lt;li&gt;Alfred&lt;/li&gt;
&lt;li&gt;Chrome&lt;/li&gt;
&lt;li&gt;Dropbox&lt;/li&gt;
&lt;li&gt;Firefox&lt;/li&gt;
&lt;li&gt;Fraise&lt;/li&gt;
&lt;li&gt;GoogleIME&lt;/li&gt;
&lt;li&gt;IntelliJ IDEA&lt;/li&gt;
&lt;li&gt;iTerm2&lt;/li&gt;
&lt;li&gt;Karabiner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Magnet&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PhpStorm&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Slack&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tweetdeck&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Vagrant&lt;/li&gt;
&lt;li&gt;Virtualbox&lt;/li&gt;
&lt;li&gt;WebStorm&lt;/li&gt;
&lt;li&gt;XtraFinder&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;設定:092daf0005039ce086d26e3201a21bf4&#34;&gt;設定&lt;/h1&gt;

&lt;h2 id=&#34;基本:092daf0005039ce086d26e3201a21bf4&#34;&gt;基本&lt;/h2&gt;

&lt;p&gt;まずバッテリーアイコンをクリックして割合(%)を表示するようにする。あとは自分はDockが画面の左側にあって自動で隠れるのが好きなのでその設定をしてクソみたいなアプリをDockから消す。&lt;/p&gt;

&lt;h2 id=&#34;セキュリティとプライバシー:092daf0005039ce086d26e3201a21bf4&#34;&gt;セキュリティとプライバシー&lt;/h2&gt;

&lt;p&gt;スリープとスクリーンセーバの解除にパスワードを要求 →  すぐに
ファイアウォール →  オン&lt;/p&gt;

&lt;h2 id=&#34;キーボード:092daf0005039ce086d26e3201a21bf4&#34;&gt;キーボード&lt;/h2&gt;

&lt;p&gt;環境光が暗い場合にキーボードの輝度を調整 → 無効
修飾キー → CapsLockキー → Control キー&lt;/p&gt;

&lt;h2 id=&#34;トラックパッド:092daf0005039ce086d26e3201a21bf4&#34;&gt;トラックパッド&lt;/h2&gt;

&lt;p&gt;タップでクリック →　有効
副ボタンのクリック → 左下隅をクリック
調べる → 無効
3本指のドラッグ → 有効
軌跡の速さ → 最大
通知センター → 無効
アプリケーションExposé → 有効&lt;/p&gt;

&lt;h2 id=&#34;アプリケーション:092daf0005039ce086d26e3201a21bf4&#34;&gt;アプリケーション&lt;/h2&gt;

&lt;p&gt;Karabiner,Magnet,XtraFinderの設定をいい感じにする。Karabinerのxmlファイルはこれを使っている。
Vimのためのに使っている感じだ。あとは &lt;code&gt;Use Japanese Keyboard as US Keyboard&lt;/code&gt; にチェックをいれて終わり。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;root&amp;gt;
  &amp;lt;list&amp;gt;
    &amp;lt;item&amp;gt;
      &amp;lt;name&amp;gt;LeaveInsMode with EISUU(Terminal)&amp;lt;/name&amp;gt;
      &amp;lt;identifier&amp;gt;private.app_terminal_esc_with_eisuu&amp;lt;/identifier&amp;gt;
      &amp;lt;only&amp;gt;TERMINAL&amp;lt;/only&amp;gt;
      &amp;lt;autogen&amp;gt;--KeyToKey-- KeyCode::ESCAPE, KeyCode::ESCAPE, KeyCode::JIS_EISUU&amp;lt;/autogen&amp;gt;
      &amp;lt;autogen&amp;gt;--KeyToKey-- KeyCode::C, VK_CONTROL, KeyCode::C, VK_CONTROL, KeyCode::JIS_EISUU&amp;lt;/autogen&amp;gt;
    &amp;lt;/item&amp;gt;
    &amp;lt;item&amp;gt;
      &amp;lt;name&amp;gt;Escape to EISUU+Escape only terminal&amp;lt;/name&amp;gt;
      &amp;lt;identifier&amp;gt;remap.jis_escape2eisuuAndEscape_terminal&amp;lt;/identifier&amp;gt;
      &amp;lt;only&amp;gt;TERMINAL&amp;lt;/only&amp;gt;
      &amp;lt;autogen&amp;gt;--KeyOverlaidModifier-- KeyCode::ESCAPE, KeyCode::JIS_EISUU, KeyCode::ESCAPE&amp;lt;/autogen&amp;gt;
    &amp;lt;/item&amp;gt;
  &amp;lt;/list&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;雑感:092daf0005039ce086d26e3201a21bf4&#34;&gt;雑感&lt;/h1&gt;

&lt;p&gt;激自動化したい状態。最初の方はただスクリプト書くだけで良さそうだけどGUIアプリケーションのとこをどうにかしたい。とても面倒なので&amp;hellip;でもCaskは使いたくないなぁという気持ち。うーん。。。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Vimのコマンドライン上でEmacs風の動作をさせる</title>
          <link>http://upamune.github.io/blog/2015/07/18/vim-commandline-like-emacs/</link>
          <pubDate>Sat, 18 Jul 2015 00:42:24 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/18/vim-commandline-like-emacs/</guid>
          <description>&lt;p&gt;コマンドライン上で長めのコマンドを入力したときに先頭にパッと飛ぼうと思ってCtrl-Aを押しても飛べなかったのでその設定をメモ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;cnoremap &amp;lt;C-A&amp;gt; &amp;lt;Home&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでCtrl-Aで先頭に飛べるようになる。デフォルトでCtrl-Eで末尾には飛べるのでちょっと謎。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;追記&lt;/p&gt;

&lt;p&gt;Ctrl-k も使いたかったのでこの設定も追記した。ちなみにカーソルから行末まで削除。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;cnoremap &amp;lt;C-K&amp;gt; &amp;lt;C-\&amp;gt;e&amp;lt;SID&amp;gt;KillLine()&amp;lt;CR&amp;gt;
function! &amp;lt;SID&amp;gt;KillLine()
  call &amp;lt;SID&amp;gt;saveUndoHistory(getcmdline(), getcmdpos())
  let l:cmd = getcmdline()
  let l:rem = strpart(l:cmd, getcmdpos() - 1)
  if (&#39;&#39; != l:rem)
    let @c = l:rem
  endif
  let l:ret = strpart(l:cmd, 0, getcmdpos() - 1)
  call &amp;lt;SID&amp;gt;saveUndoHistory(l:ret, getcmdpos())
  return l:ret
endfunction
let s:oldcmdline = [ ]
function! &amp;lt;SID&amp;gt;saveUndoHistory(cmdline, cmdpos)
  if len(s:oldcmdline) == 0 || a:cmdline != s:oldcmdline[0][0]
    call insert(s:oldcmdline, [ a:cmdline, a:cmdpos ], 0)
  else
    let s:oldcmdline[0][1] = a:cmdpos
  endif
  if len(s:oldcmdline) &amp;gt; 100
   call remove(s:oldcmdline, 100)
  endif
endfunction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/houtsnip/vim-emacscommandline&#34;&gt;vim-emacscommandline&lt;/a&gt;
VimScript書けないのでここから拝借した。このプラグインいれてもいいのだけれど、この2つで十分なので。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>NeoBundleのプラグインをTOMLで管理する</title>
          <link>http://upamune.github.io/blog/2015/07/11/vim-neobundle-toml/</link>
          <pubDate>Sat, 11 Jul 2015 11:09:19 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/11/vim-neobundle-toml/</guid>
          <description>

&lt;h1 id=&#34;why:f672304acd8d7d1eaad625c44d73da7d&#34;&gt;Why?&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;.vimrc&lt;/code&gt; が肥大化してきて、分割したいなーと思っていたのだけれど, &lt;code&gt;NeoBundle&lt;/code&gt; にはTOMLパーサが同梱されてるらしいのでプラグインだけTOMLファイルで管理することにした。あといい感じに遅延読み込みを設定して高速化させたかったってのもある。&lt;/p&gt;

&lt;h1 id=&#34;設定:f672304acd8d7d1eaad625c44d73da7d&#34;&gt;設定&lt;/h1&gt;

&lt;p&gt;ShougoさんによるTOMLファイルのサンプルは&lt;a href=&#34;https://github.com/Shougo/shougo-s-github/blob/master/vim/rc/neobundle.toml&#34;&gt;こちら&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note: TOML parser is slow.  You should use neobundle cache feature.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NeoBundle&lt;/code&gt; のヘルプによるとTOMLパーサは遅いらしいのでキャッシュを利用するようにする。&lt;/p&gt;

&lt;p&gt;こんな感じ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;if neobundle#load_cache()
  NeoBundleFetch &#39;Shougo/neobundle.vim&#39;
  call neobundle#load_toml(&#39;~/.vim/neobundle.toml&#39;)
  call neobundle#load_toml(&#39;~/.vim/neobundlelazy.toml&#39;, {&#39;lazy&#39; :1} )
  NeoBundleSaveCache
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは、TOMLファイルにプラグインを羅列していくだけ。TOMLのコメントは &lt;code&gt;#&lt;/code&gt; です。&lt;/p&gt;

&lt;h2 id=&#34;neobundle-toml:f672304acd8d7d1eaad625c44d73da7d&#34;&gt;neobundle.toml&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# syntax {{{
[[plugins]]
repository = &#39;scrooloose/syntastic&#39;

# appearance {{{
[[plugins]]
repository = &#39;itchyny/lightline.vim&#39;

# complement {{{
[[plugins]]
repository = &#39;Shougo/neocomplete.vim&#39;

# l10n {{{
[[plugins]]
repository = &#39;vim-jp/vimdoc-ja&#39;

# unite {{{
[[plugins]]
repository = &#39;Shougo/unite.vim&#39;

[[plugins]]
repository = &#39;Shougo/unite-outline&#39;

# benry {{{

[[plugins]]
repository = &#39;tyru/caw.vim.git&#39;

[[plugins]]
repository = &#39;kana/vim-submode&#39;

[[plugins]]
repository = &#39;Shougo/vimproc.vim&#39;

  [plugins.build]
    windows = &#39;tools\\update-dll-mingw&#39;
    cygwin = &#39;make -f make_cygwin.mak&#39;
    mac = &#39;make -f make_mac.mak&#39;
    unix = &#39;make -f make_unix.mak&#39;

# move {{{
[[plugins]]
repository = &#39;Lokaltog/vim-easymotion&#39;

# search {{{
[[plugins]]
repository = &#39;haya14busa/incsearch.vim&#39;
depends = &#39;osyo-manga/vim-anzu&#39;

# color {{{
[[plugins]]
repository = &#39;w0ng/vim-hybrid&#39;

[[plugins]]
repository = &#39;nanotech/jellybeans.vim&#39;

[[plugins]]
repository = &#39;upamune/tomorrow-theme&#39;

# optimize {{{
[[plugins]]
repository = &#39;Yggdroot/indentLine&#39;

[[plugins]]
repository = &#39;bronson/vim-trailing-whitespace&#39;

# git {{{
[[plugins]]
repository = &#39;lambdalisue/vim-gista&#39;

[[plugins]]
repository = &#39;gregsexton/gitv&#39;

[[plugins]]
repository = &#39;tpope/vim-fugitive&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;neobundlelazy-toml:f672304acd8d7d1eaad625c44d73da7d&#34;&gt;neobundlelazy.toml&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# like ide {{{
[[plugins]]
repository = &#39;Shougo/vimfiler&#39;
explorer = 1
mappings = &#39;&amp;lt;Plug&amp;gt;&#39;

[[plugins]]
repository = &#39;majutsushi/tagbar&#39;
mappings = &#39;&amp;lt;Plug&amp;gt;&#39;

[[plugins]]
repository = &#39;thinca/vim-quickrun&#39;
mappings = &#39;&amp;lt;Plug&amp;gt;&#39;

[[plugins]]
repository = &#39;Shougo/neosnippet&#39;
insert = 1

[[plugins]]
repository = &#39;sjl/gundo.vim&#39;
mappings = &#39;&amp;lt;Plug&amp;gt;&#39;

# search {{{
[[plugins]]
repository = &#39;rking/ag.vim&#39;
mappings = &#39;&amp;lt;Plug&amp;gt;&#39;

# benrify {{{
[[plugins]]
repository = &#39;Shougo/vimshell.vim&#39;
mappings = &#39;&amp;lt;Plug&amp;gt;&#39;

# ruby {{{
[[plugins]]
repository = &#39;marcus/rsense&#39;
filetypes = &#39;ruby&#39;

[[plugins]]
repository = &#39;supermomonga/neocomplete-rsense.vim&#39;
filetypes = &#39;ruby&#39;

[[plugins]]
repository = &#39;thinca/vim-ref&#39;
filetypes = &#39;ruby&#39;

[[plugins]]
repository = &#39;yuku-t/vim-ref-ri&#39;
filetypes = &#39;ruby&#39;

[[plugins]]
repository = &#39;tpope/vim-endwise&#39;
filetypes = &#39;ruby&#39;

# go {{{
[[plugins]]
repository = &#39;dgryski/vim-godef&#39;
filetypes = &#39;go&#39;

[[plugins]]
repository = &#39;vim-jp/vim-go-extra&#39;
filetypes = &#39;go&#39;

# clang {{{
[[plugins]]
repository = &#39;rhysd/vim-clang-format&#39;
depends = &#39;kana/vim-operator-user&#39;
filetypes = &#39;cpp&#39;

# html {{{
[[plugins]]
repository = &#39;amirh/HTML-AutoCloseTag&#39;
filetypes = &#39;html&#39;

[[plugins]]
repository = &#39;hail2u/vim-css3-syntax&#39;
filetypes = &#39;html&#39;

[[plugins]]
repository = &#39;gorodinskiy/vim-coloresque&#39;
filetypes = &#39;html&#39;

[[plugins]]
repository = &#39;tpope/vim-haml&#39;
filetypes = &#39;html&#39;

[[plugins]]
repository = &#39;mattn/emmet-vim&#39;
filetypes = &#39;html&#39;

# toml {{{
[[plugins]]
repository = &#39;cespare/vim-toml&#39;
filetypes = &#39;toml&#39;

# scala {{{
[[plugins]]
repository = &#39;derekwyatt/vim-scala&#39;
filetypes = &#39;scala&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ:f672304acd8d7d1eaad625c44d73da7d&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;TOMLファイルに移行させるのはほとんどコピペで &lt;code&gt;s/NeoBundle /[[plugins]]\rrepository = /&lt;/code&gt; 的なことをするだけだったので楽だった。実際の起動時間は 246ms =&amp;gt; 133ms になって &lt;strong&gt;113ms&lt;/strong&gt; も速くなったので最高です。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ArchLinux をインストールする with Btrfs</title>
          <link>http://upamune.github.io/blog/2015/07/10/archlinux_install_btrfs/</link>
          <pubDate>Fri, 10 Jul 2015 00:02:18 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/10/archlinux_install_btrfs/</guid>
          <description>

&lt;h1 id=&#34;インストール以前:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;インストール以前&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.archlinux.org/download/&#34;&gt;Arch Linux Downloads&lt;/a&gt;から最新版のISOをダウンロードしてくる。そしてUSBメモリをさして焼けばいいのだけれど、自分は毎回以下のようにやっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lsblk #USBメモリを確認
$ dd bs=4M if=archlinux.iso of=/dev/sdX #lsblkで確認したデバイスに焼く
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎回のように &lt;code&gt;dd&lt;/code&gt; の進捗を確認する方法を検索してしまうのでメモ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo sh -c &#39;while true; do killall -USR1 dd; sleep 2; done&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすると2秒おきに進捗が見れるらしい。べんり。
&lt;a href=&#34;http://kaworu.jpn.org/kaworu/2012-11-29-1.php&#34;&gt;CentOS ddコマンド実行中に進捗情報を確認する方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;BSD系だと使えないので注意。&lt;/p&gt;

&lt;h1 id=&#34;archlinuxのインストール:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;ArchLinuxのインストール&lt;/h1&gt;

&lt;h2 id=&#34;ネットワークに接続する:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;ネットワークに接続する&lt;/h2&gt;

&lt;p&gt;ネットワークに接続しないとなにも始まらないので接続。有線でも無線でも良い。
無線の場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# wifi-menu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で接続。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# ping 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接続確認。&lt;/p&gt;

&lt;h2 id=&#34;ssh-接続する:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;ssh 接続する&lt;/h2&gt;

&lt;p&gt;そのまま設定を手打ちするのは面倒くさいので, sshで接続して設定をする。&lt;/p&gt;

&lt;h3 id=&#34;ホスト側:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;ホスト側&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# sytemctl start sshd
# systmctl status sshd
# ip a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IPアドレスを確認しておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、rootパスワードを設定しておきます。&lt;/p&gt;

&lt;h3 id=&#34;クライアント側:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;クライアント側&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ssh root@IP_ADDR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ssh接続確認できたら、次に進む。&lt;/p&gt;

&lt;h2 id=&#34;パーティション:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;パーティション&lt;/h2&gt;

&lt;p&gt;一番面倒くさい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# cgdisk /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなかんじにした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;NAME             MAJ:MIN  RM  SIZE    RO  TYPE
 sda
 │─sda1            8:1     0    512M   0   part
 ├─sda2            8:2     0      1G   0   part
 └─sda3            8:3     0  117.8G   0   part
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;フォーマット:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;フォーマット&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# mkfs.vfat -F32 /dev/sda1
# mkswap /dev/sda2
# mkfs.btrfs /dev/sda3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;マウント:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;マウント&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# mount -o noatime,discard,ssd,autodefrag,compress=lzo,space_cache /dev/sda3 /mnt
# mkdir -p /mnt/boot/efi
# mount /dev/sda1 /mnt/boot/efi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pacstrap:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;pacstrap&lt;/h2&gt;

&lt;p&gt;パーティションが終わったらあとは楽ちん。 &lt;code&gt;pacstrap&lt;/code&gt; を使って必要なソフト群をインストールする。その前にミラーリストの順序を変更しておくと良い。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# vi /etc/pacman.d/mirrorlist # Japanを上に持ってくる
# pacstrap /mnt base base-devel grub efibootmgr dosfstools btrfs-progs lzo dialog wpa_supplicant openssh git vim zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこそこ時間がかかるので待つ。&lt;/p&gt;

&lt;h2 id=&#34;設定:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;設定&lt;/h2&gt;

&lt;h3 id=&#34;fstab:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;fstab&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# genfstab -p /mnt &amp;gt;&amp;gt; /mnt/etc/fstab
# vim /mnt/etc/fstab #/dev/sda の形式ではなくて,UUID=の形式に置き換える
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;諸設定:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;諸設定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# arch-chroot /mnt `which zsh`
# passwd
# echo HOSTNAME &amp;gt; /etc/hostname
# ln -s /usr/share/zoneinfo/Asia/Tokyo /etc/localtime
# echo &#39;LANG=en_US.UTF-8&#39; &amp;gt; /etc/locale.conf
# vim /etc/locale.gen # en_US.UTF-8 のコメントアウトを解除する
# locale-gen
# vim /etc/mkinitcpio.conf # HOOKSのfsck のあとにbtrfsを追加する
# mkinitcpio -p linux
# mkdir /boot/efi/EFI
# grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=Grub --recheck --debug
# grub-mkconfig -o /boot/grub/grub.cfg
# exit
# umount /mnt/{boot/efi,}
# reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまででArchLinuxのインストールは完了です。次は基本的な設定をしていきます&lt;/p&gt;

&lt;p&gt;また先ほどの要領でssh接続して進める。&lt;/p&gt;

&lt;h2 id=&#34;pacman-yaourt:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;pacman &amp;amp; yaourt&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;/etc/pacman.conf&lt;/code&gt; を設定してmultilibを有効にしておく。&lt;/p&gt;

&lt;p&gt;そしてこれも末尾に追記しておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[archlinuxfr]
SigLevel = Never
Server = http://repo.archlinux.fr/$arch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;追記し終わったら、更新して &lt;code&gt;yaourt&lt;/code&gt; を有効にしておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# pacman --sync --refresh yaourt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ユーザー作成:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;ユーザー作成&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# useradd -m -G wheel -s /bin/zsh upamune
# passwd upamune
# visudo # %wheel ALL=(ALL) ALL のコメントアウトを解除する
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ユーザー作成したのでこれからはrootユーザーではなく作成したユーザーで作業していく。&lt;/p&gt;

&lt;h1 id=&#34;gui構築:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;GUI構築&lt;/h1&gt;

&lt;p&gt;Xfce + SLiM です。&lt;/p&gt;

&lt;h2 id=&#34;slim-導入:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;SLiM 導入&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -Sy xorg-server xorg-server-utils xorg-server-xephyr xorg-utils xterm xf86-video-intel slim archlinux-themes-slim slim-themes
$ vim /etc/slim.conf # login_cmd, daemon の行のコメントアウトを解除して、 themeも変更
$ systemctl enable slim.service
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;xfce-導入:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;Xfce 導入&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S xfce4 xfce4-goodies gamin
$ vim ~/.xinitrc # exec startxfce4 と書けば良い
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;インストール後:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;インストール後&lt;/h2&gt;

&lt;h3 id=&#34;プログラミング言語系:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;プログラミング言語系&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S clang go scala
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ツール:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;ツール&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S chromium dropbox gimp guake mikutter mercurial tig xsel tlp tp-smapi tpacpi-bat tmux the_silver_searcher unzip wpa_actiond
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;wpa_actiond&lt;/code&gt; をインストールすることで &lt;code&gt;netctl-auto&lt;/code&gt; が入るので、ネットワークに自動接続するように設定する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable netctl-auto@[INTERFACE].service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに &lt;code&gt;tlp&lt;/code&gt; を有効にするためにも設定しておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl enable tlp.service
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;開発環境:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;開発環境&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S ctags typesafe-activator intellij-idea-ultimate-edition
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;フォント:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;フォント&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S ttf-koruri ttf-ricty otf-ipaexfont ttf-symbola
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;日本語入力:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;日本語入力&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S fcitx-qt5 fcitx-im fcitx-configtool fcitx-mozc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インストール後にFcitx Configuration からMozcを追加する必要がある。&lt;/p&gt;

&lt;h3 id=&#34;テーマ:7ecbc99fb37e3d3ed4682d3347f70c22&#34;&gt;テーマ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt numix-themes-git numix-icon-theme-git
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>IntelliJでGoを書く</title>
          <link>http://upamune.github.io/blog/2015/07/05/go_with_intellij/</link>
          <pubDate>Sun, 05 Jul 2015 19:24:06 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/05/go_with_intellij/</guid>
          <description>&lt;p&gt;IntelliJ IDEAでGoを書く環境を整えようと思ったのだけれど、普通にプラグイン検索してもヒットしなかったのでメモ。ちなみにOSはArchLinux。&lt;/p&gt;

&lt;p&gt;基本的に&lt;a href=&#34;http://stormcat.hatenablog.com/entry/2015/04/13/123000&#34;&gt;ここ&lt;/a&gt;を参照すればいいのだけど、Goをbrewではなくてyaourtでインストールしたので、SDKの設定をするときにどこにPATHを通せばいいのか迷った。
おそらく&lt;code&gt;GOROOT&lt;/code&gt;を指定すればいいのだけれど、&lt;code&gt;GOROOT&lt;/code&gt;を設定していないので、どこが&lt;code&gt;GOROOT&lt;/code&gt; になっているか分からなかったので調べた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go env GOROOT
/usr/lib/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていたので、ここのディレクトリを指定するとうまくいった。あとは&lt;code&gt;GOPATH&lt;/code&gt; も訊かれるので設定しておく。これでIntelliJで最低限Goを書ける環境は整った。&lt;/p&gt;

&lt;p&gt;保存時に自動的に&lt;code&gt;gofmt&lt;/code&gt;かけてほしいなぁ&amp;hellip;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AOJ 0004 - 0009 を埋めた</title>
          <link>http://upamune.github.io/blog/2015/07/05/aoj_ume0/</link>
          <pubDate>Sun, 05 Jul 2015 13:38:24 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/05/aoj_ume0/</guid>
          <description>

&lt;h1 id=&#34;0004:e4e007fb7c0784763ddbe00555507573&#34;&gt;0004&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0004&#34;&gt;Simultaneous Equation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;連立方程式の解は1意に定まると書いてあるので、楽ちん。&lt;code&gt;小数点以下第４位を四捨五入&lt;/code&gt; に注意する。あと、負のゼロが出る場合があるのでその時は &lt;code&gt;0&lt;/code&gt; に直さなければならない。&lt;/p&gt;

&lt;h2 id=&#34;コード:e4e007fb7c0784763ddbe00555507573&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main(void) {
  double x1, x2, y1, y2, X, Y;

  while (cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; X &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; Y) {
    double det = 1.0 / (x1 * y2 - x2 * y1);
    double ansX = det * (y2 * X - y1 * Y);
    double ansY = det * (x1 * Y - x2 * X);

    if (ansX == 0) ansX = abs(ansX);
    if (ansY == 0) ansY = abs(ansY);

    printf(&amp;quot;%.3f %.3f\n&amp;quot;, ansX, ansY);
  }

  return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;0005:e4e007fb7c0784763ddbe00555507573&#34;&gt;0005&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0005&#34;&gt;GCD and LCM&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GCD(最大公約数) とLCM(最大公約数) を求めるだけ。 lcm の計算順に注意する。&lt;code&gt;a * b&lt;/code&gt; を先にやってしまうと、オーバーフローする場合がある(サンプル2)。&lt;/p&gt;

&lt;h2 id=&#34;コード-1:e4e007fb7c0784763ddbe00555507573&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main(void) {
  cin.tie(0);
  ios::sync_with_stdio(false);

  int a, b;
  while (cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b) {
    int gcd = __gcd(a, b);
    int lcm = a / gcd * b;

    cout &amp;lt;&amp;lt; gcd &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; lcm &amp;lt;&amp;lt; endl;
  }

  return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;0006:e4e007fb7c0784763ddbe00555507573&#34;&gt;0006&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0006&#34;&gt;Reverse Sequence&lt;/a&gt;
与えられた文字列を逆順にして出力する。&lt;/p&gt;

&lt;h2 id=&#34;コード-2:e4e007fb7c0784763ddbe00555507573&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main(void) {
  cin.tie(0);
  ios::sync_with_stdio(false);

  string str;
  cin &amp;gt;&amp;gt; str;
  reverse(begin(str), end(str));
  cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;0007:e4e007fb7c0784763ddbe00555507573&#34;&gt;0007&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0007&#34;&gt;Debt Hell&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;利子を計算するだけだけど、1000円未満を切り上げることに注意。ループ毎に切り上げる。&lt;/p&gt;

&lt;h2 id=&#34;コード-3:e4e007fb7c0784763ddbe00555507573&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i, n) for (int i = 0; i &amp;lt; n; i++)

int main(void) {
  cin.tie(0);
  ios::sync_with_stdio(false);

  int n;
  int money = 100000;
  cin &amp;gt;&amp;gt; n;
  rep(i, n) {
    money *= 1.05;
    if (money % 1000 == 0) continue;
    money += 1000 - money % 1000;
  }

  cout &amp;lt;&amp;lt; money &amp;lt;&amp;lt; endl;

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;0008:e4e007fb7c0784763ddbe00555507573&#34;&gt;0008&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0008&#34;&gt;Sum of 4 Integers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4重ループ。&lt;/p&gt;

&lt;h2 id=&#34;コード-4:e4e007fb7c0784763ddbe00555507573&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i, n) for (int i = 0; i &amp;lt; n; i++)

int main(void) {
  cin.tie(0);
  ios::sync_with_stdio(false);

  int n;
  while (cin &amp;gt;&amp;gt; n) {
    int cnt = 0;
    rep(i, 10) rep(j, 10) rep(k, 10) rep(l, 10) if (i + j + k + l == n) cnt++;

    cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl;
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;0009:e4e007fb7c0784763ddbe00555507573&#34;&gt;0009&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0009&#34;&gt;Prime Number&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード-5:e4e007fb7c0784763ddbe00555507573&#34;&gt;コード&lt;/h2&gt;

&lt;p&gt;素数判定。よく, &lt;code&gt;make_prime()&lt;/code&gt; を呼び忘れるので気をつけたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i, n) for (int i = 0; i &amp;lt; n; i++)
#define N 1000001

int prime[N];

void make_prime() {  // primeが0だったら素数
  fill(prime, prime + N, 0);
  prime[0] = prime[1] = 1;

  for (int i = 2; i * i &amp;lt; N; i++) {
    if (prime[i] == 0) {
      for (int j = 2 * i; j &amp;lt; N; j += i) {
        prime[j] = 1;
      }
    }
  }
}

int main(void) {
  cin.tie(0);
  ios::sync_with_stdio(false);

  int n;
  make_prime();
  while (cin &amp;gt;&amp;gt; n) {
    int cnt = 0;

    rep(i, n + 1) {
      if (prime[i] == 0) cnt++;
    }

    cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl;
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AOJ_1127 Building a Space Station</title>
          <link>http://upamune.github.io/blog/2015/07/04/aoj_1127/</link>
          <pubDate>Sat, 04 Jul 2015 23:30:19 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/04/aoj_1127/</guid>
          <description>

&lt;h1 id=&#34;問題:440da21818b707842ee80e24834a81cc&#34;&gt;問題&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127&#34;&gt;Building a Space Station&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;コード:440da21818b707842ee80e24834a81cc&#34;&gt;コード&lt;/h1&gt;

&lt;p&gt;最小全域木の問題なのだけれど、そのまんまの問題ではない。ちょっといじくってからやる。2つの半径分を引くのを忘れない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i, n) for (int i = 0; i &amp;lt; n; i++)
#define MAX_V 101

int n, m;

int par[MAX_V];
int rrank[MAX_V];

void init(int n) {
  rep(i, n) {
    par[i] = i;
    rrank[i] = 0;
  }
}

int find(int x) {
  if (par[x] == x) {
    return x;
  } else {
    return par[x] = find(par[x]);
  }
}

void unite(int x, int y) {
  x = find(x);
  y = find(y);

  if (x == y) return;

  if (rrank[x] &amp;lt; rrank[y]) {
    par[x] = y;
  } else {
    par[y] = x;
    if (rrank[x] == rrank[y]) rrank[x]++;
  }
}

bool same(int x, int y) { return find(x) == find(y); }

struct Edge {
  int u;
  int v;
  double cost;
};

struct Cell {
  double x,y,z,r;
};

Edge es[10000];

double kruskal() {
  sort(es, es + m,
      [](const Edge &amp;amp;e1, const Edge &amp;amp;e2) { return e1.cost &amp;lt; e2.cost; });
  init(n);
  double res = 0.0;
  rep(i, m) {
    Edge e = es[i];
    if (!same(e.u, e.v)) {
      unite(e.u, e.v);
      res += e.cost;
    }
  }
  return res;
}

int main(void) {
  cin.tie(0);
  ios::sync_with_stdio(false);

  while (1) {
    cin &amp;gt;&amp;gt; n;
    if(n == 0) break;
    m = 0;
    Cell c[MAX_V];
    rep(i, n) {
      double x, y, z, r;
      cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z &amp;gt;&amp;gt; r;
      c[i].x = x;
      c[i].y = y;
      c[i].z = z;
      c[i].r = r;
    }

    rep(i,n){
      for(int j = i + 1; j &amp;lt; n; j++){
        double d = pow(c[i].x - c[j].x,2) + pow(c[i].y - c[j].y,2) + pow(c[i].z - c[j].z,2);
        d = max(0.0,sqrt(d)-c[i].r-c[j].r);
        Edge e;
        e.u = i;
        e.v = j;
        e.cost = d;
        es[m] = e;
        m++;
      }
    }
    printf(&amp;quot;%.3f\n&amp;quot;, kruskal());
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プリム法でも実装できるようにならないとなぁ&amp;hellip;。C++の構造体のコンストラクタ書けるようになったほうが良さそう。あと、sortの比較のために関数をラムダ式で書いてみた。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AOJ_0189 Convenient Location</title>
          <link>http://upamune.github.io/blog/2015/07/04/aoj_0189/</link>
          <pubDate>Sat, 04 Jul 2015 21:51:25 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/04/aoj_0189/</guid>
          <description>

&lt;h1 id=&#34;問題:b61f7183e17ce5f7633c8b811ff9c6a5&#34;&gt;問題&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0189&#34;&gt;Convenient Location&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;コード:b61f7183e17ce5f7633c8b811ff9c6a5&#34;&gt;コード&lt;/h1&gt;

&lt;p&gt;すべての2頂点間の最短路を求める問題なのでワーシャルフロイドを使うっぽい。街の数くらい与えてくれてもいいじゃん&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i,n) for(int i=0;i&amp;lt;n;i++)
#define inf INT_MAX/4
#define MAX_V 11

int n;
int d[MAX_V][MAX_V];
int V;


void init(){
  V = 0;
  rep(i,MAX_V){
    rep(j,MAX_V){
      if(i == j){
        d[i][j] = 0;
      }else{
        d[i][j] = inf;
      }
    }
  }
}

int main(void){

  while(1){
    cin &amp;gt;&amp;gt; n;
    if(n == 0) break;

    init();
    rep(i,n){
      int a, b, c;
      cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
      d[a][b] = c;
      d[b][a] = c;
      V = max(max(V,a),b);
    }
    V++;

    // Warshall-Floyd
    rep(k,V){
      rep(i,V){
        rep(j,V){
          d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
        }
      }
    }

    int city, cost = inf;
    rep(i,V){
      int cnt = 0;
      rep(j,V){
        cnt += d[i][j];
      }
      if(cost &amp;gt; cnt){
        cost = cnt;
        city = i;
      }
    }

    cout &amp;lt;&amp;lt; city &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; cost &amp;lt;&amp;lt; endl;
  }


  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AOJ_0180 Stellar Performance of the Debunkey Family</title>
          <link>http://upamune.github.io/blog/2015/07/04/aoj_0180/</link>
          <pubDate>Sat, 04 Jul 2015 20:43:05 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/04/aoj_0180/</guid>
          <description>

&lt;h1 id=&#34;問題:df539b29af2548c6bc04a959b239110f&#34;&gt;問題&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0180&#34;&gt;Stellar Performance of the Debunkey Family&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最小全域木。クラスカル法でやってみます。&lt;/p&gt;

&lt;h1 id=&#34;コード:df539b29af2548c6bc04a959b239110f&#34;&gt;コード&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i,n) for(int i=0;i&amp;lt;n;i++)
#define MAX_V 101

int n,m;

// Union-Find
int par[MAX_V];
int rrank[MAX_V];

void init(int n){
  rep(i,n){
    par[i] = i;
    rrank[i] = 0;
  }
}

int find(int x){
  if(par[x] == x){
    return x;
  }else{
    return par[x] = find(par[x]);
  }
}

void unite(int x, int y){
  x = find(x);
  y = find(y);

  if(x == y) return;

  if(rrank[x] &amp;lt; rrank[y]){
    par[x] = y;
  }else{
    par[y] = x;
    if(rrank[x] == rrank[y]) rrank[x]++;
  }
}

bool same(int x, int y){
  return find(x) == find(y);
}

// Union-Find

struct Edge{
  int u;
  int v;
  int cost;
};

bool comp(const Edge&amp;amp;e1, const Edge&amp;amp;e2){
  return e1.cost &amp;lt; e2.cost;
}

Edge es[10000];


int kruskal(){
  sort(es, es+m, comp);
  init(n);
  int res = 0;
  rep(i,m){
    Edge e = es[i];
    if(!same(e.u, e.v)){
      unite(e.u,e.v);
      res += e.cost;
    }
  }

  return res;
}

int main(void){
  cin.tie(0);
  ios::sync_with_stdio(false);

  while(1){
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    if(n == 0 &amp;amp;&amp;amp; m == 0) break;
    rep(i,m){
      cin &amp;gt;&amp;gt; es[i].u &amp;gt;&amp;gt; es[i].v &amp;gt;&amp;gt; es[i].cost;
    }
    cout &amp;lt;&amp;lt; kruskal() &amp;lt;&amp;lt; endl;
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AOJ_0122 Summer of Phyonkichi</title>
          <link>http://upamune.github.io/blog/2015/07/04/aoj_0122/</link>
          <pubDate>Sat, 04 Jul 2015 16:31:39 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/04/aoj_0122/</guid>
          <description>

&lt;h1 id=&#34;問題:22d384d0fc683c1b15d7dbd633c94a9c&#34;&gt;問題&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0122&#34;&gt;Summer of Phyonkichi&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;コード:22d384d0fc683c1b15d7dbd633c94a9c&#34;&gt;コード&lt;/h1&gt;

&lt;p&gt;DFS苦手なのでDFSで書いてみた。遷移先のdx,dyが面倒くさい。
flog_dx, flog_dy を間違えていて（カンマを忘れていた）無限に時間を無駄にした&amp;hellip;
dx,dy系は要素数を指定して宣言するのが良さそう。（要素数が足りなかったり多かったりしたらエラーになる)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i, n) for (int i = 0; i &amp;lt; n; i++)

const int flog_dx[] = {-2, -2, -2, - 1, -1, 0, 0, 1, 1, 2, 2, 2};
const int flog_dy[] = {-1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1};
const int sprin_dx[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};
const int sprin_dy[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};
int flogX;
int flogY;
int sprinX[10];
int sprinY[10];
int sprinN;
bool flag;

void dfs(int x, int y, int now) {
  rep(i, 12) {
    int nx = x + flog_dx[i];
    int ny = y + flog_dy[i];
    if (nx &amp;lt; 0 || 9 &amp;lt; nx || ny &amp;lt; 0 || 9 &amp;lt; ny) continue;
    // 水がかかるかどうか
    rep(j, 9) {
      if (nx == sprinX[now] + sprin_dx[j] &amp;amp;&amp;amp; ny == sprinY[now] + sprin_dy[j]) {
        if (now + 1 == sprinN) {
          flag = true;
          break;
        }
        dfs(nx, ny, now + 1);
      }
    }
  }
}

int main(void) {
  while (1) {
    cin &amp;gt;&amp;gt; flogX &amp;gt;&amp;gt; flogY;
    if (flogX == 0 &amp;amp;&amp;amp; flogY == 0) break;
    cin &amp;gt;&amp;gt; sprinN;
    rep(i, sprinN) { cin &amp;gt;&amp;gt; sprinX[i] &amp;gt;&amp;gt; sprinY[i]; }
    flag = false;
    dfs(flogX, flogY, 0);

    cout &amp;lt;&amp;lt; (flag ? &amp;quot;OK&amp;quot; : &amp;quot;NA&amp;quot;) &amp;lt;&amp;lt; endl;
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AOJ_0121 Seven Puzzle</title>
          <link>http://upamune.github.io/blog/2015/07/04/aoj_0121/</link>
          <pubDate>Sat, 04 Jul 2015 14:37:39 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/04/aoj_0121/</guid>
          <description>

&lt;h1 id=&#34;問題:f5a10f9089d983934181045248568593&#34;&gt;問題&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0121&#34;&gt;Seven Puzzle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;0から7までの数字が2行4列の枠に並んでいて、0は上下左右の数字と位置を交換できる。与えられた状態から 01234567 にするまでの最小手数を求めよ、という問題。&lt;/p&gt;

&lt;h1 id=&#34;コード:f5a10f9089d983934181045248568593&#34;&gt;コード&lt;/h1&gt;

&lt;p&gt;inputを与えられるごとにBFSしてたらTLEになるらしい。状態数は &lt;code&gt;8! = 40320&lt;/code&gt; しかないので、あらかじめゴール(01234567)からの最小手数を求めておく。階乗がつくだけでヤバイと思っていたけど、8!くらいだとそうでもないっぽい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i, n) for (int i = 0; i &amp;lt; n; i++)
#define pb push_back

const int dx[4] = {1, -1, 4, -4};

int main(void) {
  map&amp;lt;string, int&amp;gt; cost;
  string s = &amp;quot;01234567&amp;quot;;

  queue&amp;lt;string&amp;gt; q;
  q.push(s);
  cost[s] = 0;

  // !emptyより楽
  while (q.size()) {
    string now = q.front();
    q.pop();
    int pos = now.find(&amp;quot;0&amp;quot;);
    rep(i, 4) {
      int nextPos = dx[i] + pos;
      if (0 &amp;gt; nextPos || nextPos &amp;gt; 7) continue;
      // 右端と左端を交換しないように
      if (pos == 3 &amp;amp;&amp;amp; nextPos == 4 || pos == 4 &amp;amp;&amp;amp; nextPos == 3) continue;
      string next = now;
      swap(next[pos], next[nextPos]);
      // 遷移してたら無視
      if (cost.find(next) != cost.end()) continue;
      q.push(next);
      cost[next] = cost[now] + 1;
    }
  }

  string in = &amp;quot;&amp;quot;;
  while (getline(cin, in)) {
    string res = &amp;quot;&amp;quot;;
    // 空白を削除する
    rep(i, in.size()) {
      if (in[i] != &#39; &#39;) res.pb(in[i]);
    }
    cout &amp;lt;&amp;lt; cost[res] &amp;lt;&amp;lt; endl;
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;q.front();q.pop()&lt;/code&gt; って書きたいのに、ClangFormatに直されてしまう&amp;hellip;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AOJ_0072 Carden Lantern</title>
          <link>http://upamune.github.io/blog/2015/07/04/aoj_0072/</link>
          <pubDate>Sat, 04 Jul 2015 02:25:12 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/04/aoj_0072/</guid>
          <description>

&lt;h1 id=&#34;問題:cf14e657c058b6478776c41cd0cf3dab&#34;&gt;問題&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072&#34;&gt;Carden Lantern&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;どうやら最小全域木の問題らしい。最小全域木の求め方は2つあって、プリム法とクラスカル法がある。両方🐜本に載っている。勉強のために2つとも使って実装してみた。&lt;/p&gt;

&lt;h2 id=&#34;プリム法:cf14e657c058b6478776c41cd0cf3dab&#34;&gt;プリム法&lt;/h2&gt;

&lt;p&gt;初期化を忘れないようにしよう&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i,n) for(int i=0;i&amp;lt;n;i++)
#define inf INT_MAX
#define MAX_V 101

int n, m;
int cost[MAX_V][MAX_V];
int mincost[MAX_V];
bool used[MAX_V];

int prim(){
  // init
  rep(i,n){
    mincost[i] = inf;
    used[i] = false;
  }

  mincost[0] = 0;
  int res = 0;

  while(1){
    int  v = -1;
    // search min cost
    rep(u,n){
      if(!used[u] &amp;amp;&amp;amp; (v == -1 || mincost[u] &amp;lt; mincost[v])) v = u;
    }

    if(v == -1) break;

    used[v]  = true;
    res += mincost[v];

    rep(u,n){
      mincost[u] = min(mincost[u],cost[v][u]);
    }
  }
  return res;
}

int main(void){

  while(1){
    cin &amp;gt;&amp;gt; n;
    if(n == 0) break;
    cin &amp;gt;&amp;gt; m;
    rep(i,n) rep(j,n) cost[i][j] = inf;
    rep(i,m){
      int a,b,c;
      scanf(&amp;quot;%d,%d,%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
      cost[a][b] = c/100-1;
      cost[b][a] = c/100-1;
    }
    cout &amp;lt;&amp;lt; prim() &amp;lt;&amp;lt; endl;
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;クラスカル法:cf14e657c058b6478776c41cd0cf3dab&#34;&gt;クラスカル法&lt;/h2&gt;

&lt;p&gt;Union-Findがスラスラかけるんだったらこっちのほうが、わかりやすくてよい。
&lt;code&gt;Edge&lt;/code&gt; の配列を &lt;code&gt;MAX_V&lt;/code&gt; しか確保してなくて死んでいた。よくよく考えればまったく足りない。 &lt;a href=&#34;https://twitter.com/public_sate&#34;&gt;@public_sate&lt;/a&gt; に指摘されて気づいたので、感謝。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define rep(i,n) for(int i=0;i&amp;lt;n;i++)
#define inf INT_MAX
#define MAX_V 101

int n, m;

// Union-Find //
int par[MAX_V];
int rrank[MAX_V];

void init(int n){
  rep(i,n){
    par[i] = i;
    rrank[i] = 0;
  }
}

int find(int x){
  if(par[x] == x){
    return x;
  }else{
    return par[x] = find(par[x]);
  }
}

void unite(int x, int y){
  x = find(x);
  y = find(y);
  if(x == y) return;

  if(rrank[x] &amp;lt; rrank[y]){
    par[x] = y;
  }else{
    par[y] = x;
    if(rrank[x] == rrank[y]) rrank[x]++;
  }
}

bool same(int x, int y){
  return find(x) == find(y);
}
// Union-Find //

struct edge{
  int u;
  int v;
  int cost;
};

bool comp(const edge&amp;amp; e1, const edge&amp;amp; e2){
  return e1.cost &amp;lt; e2.cost;
}

edge es[10000];

int kruskal(){
  sort(es,es+m, comp);
  init(n);
  int res = 0;
  rep(i, m){
    edge e = es[i];
    if(!same(e.u,e.v)){
      unite(e.u,e.v);
      res += e.cost;
    }
  }
  return res;
}

int main(void){

  while(1){
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    if(n == 0) break;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;m);
    rep(i,m){
      int a,b,c;
      scanf(&amp;quot;%d,%d,%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
      es[i].u = a;
      es[i].v = b;
      es[i].cost = c/100-1;
    }
    printf(&amp;quot;%d\n&amp;quot;, kruskal());
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>HugoをWerckerでgithub.ioに自動デプロイさせた時にハマったこと</title>
          <link>http://upamune.github.io/blog/2015/07/01/hugo-hosting-on-githubio/</link>
          <pubDate>Wed, 01 Jul 2015 08:53:12 &#43;0900</pubDate>
          <author>Masato Yamamoto</author>
          <guid>http://upamune.github.io/blog/2015/07/01/hugo-hosting-on-githubio/</guid>
          <description>

&lt;p&gt;このブログはHugoを使っています。そして、GithubにPushしたら自動でデプロイされるようになっています。それを実現しているのが, &lt;a href=&#34;http://wercker.com/&#34;&gt;Wercker&lt;/a&gt;というWebサービスです。基本的には &lt;a href=&#34;http://motomizuki.github.io/blog/2015/02/28/hugodeploy/&#34;&gt;Hugoのインストールから自動デプロイまで&lt;/a&gt;を参考に進めていけば良いのですが、いくつかハマったことがあったのでメモしておきます。&lt;/p&gt;

&lt;h2 id=&#34;dockerを無効にする:d6227f561adea8a078b1218a682602ea&#34;&gt;Dockerを無効にする&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;box:wercker/default&lt;/code&gt; はDockerを使わないので、無効にしておきます。
デフォルトだとDockerが有効になっているのでチェックを外しておきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://f.st-hatena.com/images/fotolife/j/jajkeqos/20150701/20150701094913.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;テーマは-recursive-をつけてクローンする:d6227f561adea8a078b1218a682602ea&#34;&gt;テーマは &amp;ndash;recursive をつけてクローンする&lt;/h2&gt;

&lt;p&gt;私は、&lt;a href=&#34;https://github.com/dim0627/hugo_theme_aglaus&#34;&gt;aglaus&lt;/a&gt;というテーマを使用しているのですが、 &lt;code&gt;git clone&lt;/code&gt; するときに &lt;code&gt;--recursive&lt;/code&gt; オプションをつけてクローンしないとビルド失敗してしまいました。ですが、 &lt;code&gt;git clone --recursive git@github.com:dim0627/hugo_theme_aglaus.git&lt;/code&gt; という風にやると成功したので、つけたほうが良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;最新のhugo-buildを使用する:d6227f561adea8a078b1218a682602ea&#34;&gt;最新のhugo-buildを使用する&lt;/h2&gt;

&lt;p&gt;他人の &lt;code&gt;wercker.yml&lt;/code&gt; では hugo-build がバージョン指定されていることがあります。しかし、古いバージョンだとうまく動かないことがあるので、うまくbuildできない場合はhugo-buildの最新のものを使うとよいです。自分の場合、Hugoのテーマの Url を推奨されるURLに書き換えたらエラーが出てビルドできなかったのですが、最新版にするとちゃんとビルドできました。&lt;/p&gt;

&lt;h2 id=&#34;wercker-yml-の-インデントは半角スペース4つ:d6227f561adea8a078b1218a682602ea&#34;&gt;wercker.yml の インデントは半角スペース4つ&lt;/h2&gt;

&lt;p&gt;最初に貼った記事でも書かれていますが、 wercker.yml のインデントは半角スペース4つです。いつも自分はインデントを半角スペース2つで使用しているので、ハマりました。&lt;/p&gt;

&lt;h2 id=&#34;最終的なwercker-yml:d6227f561adea8a078b1218a682602ea&#34;&gt;最終的なwercker.yml&lt;/h2&gt;

&lt;p&gt;主にハマったところは列挙しておいたので、最後に &lt;code&gt;wercker.yml&lt;/code&gt; の内容を貼っておきます。動作したバージョンで固定しておくのが良さそうですが、まだやってません&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: wercker/default
build:
    steps:
        - arjen/hugo-build:
            theme: aglaus
            flags: --buildDrafts=true
deploy:
    steps:
        - lukevivier/gh-pages:
            token: $GIT_TOKEN
            basedir: public
            repo: upamune/upamune.github.io
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
